<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Environment with Floating Particles</title>
    <style>
      @font-face {
        font-family: "SourceCodePro";
        src: url("assets/SourceCodePro-VariableFont_wght.ttf")
          format("truetype");
      }
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
      }
      #title {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: black;
        font-size: 36px;
        font-weight: bold;
        font-family: "SourceCodePro", monospace;
        z-index: 100;
        text-align: center;
        letter-spacing: 2px;
        text-shadow: 2px 2px 4px rgba(76, 30, 30, 0.454);
      }
    </style>
  </head>
  <body>
    <div id="title">Memory_Almost_Full</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xc0d0d0);
      document.body.appendChild(renderer.domElement);

      // Lighting with shadows
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // Optimized particle system
      const particleCount = 100;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const velocities = [];

      // Initialize particles
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const r = Math.random() - 0.5;

        // Random positions in a sphere
        positions[i3] = r * 20;
        positions[i3 + 1] = r * 20;
        positions[i3 + 2] = r * 20;

        // Simplified gray color
        const grayIntensity = 0.4;
        colors[i3] = grayIntensity;
        colors[i3 + 1] = grayIntensity;
        colors[i3 + 2] = grayIntensity;

        // Random velocities for floating motion
        velocities.push({
          x: (Math.random() - 0.5) * 0.02,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.02,
        });
      }

      particles.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      // Particle material with shadow effect
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
      });

      const particleSystem = new THREE.Points(particles, particleMaterial);
      scene.add(particleSystem);

      // Simple shadow layer
      const shadowGeometry = particles.clone();
      const shadowMaterial = new THREE.PointsMaterial({
        size: 0.1,
        color: 0x4c1e1e,
        transparent: true,
        opacity: 0.3,
      });
      const shadowSystem = new THREE.Points(shadowGeometry, shadowMaterial);
      shadowSystem.position.set(-0.01, -0.01, -0.01);
      scene.add(shadowSystem);

      // Camera position
      camera.position.z = 15;

      // Simplified orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;
      controls.enablePan = true;

      // Optimized animation loop
      function animate() {
        requestAnimationFrame(animate);

        const positions = particleSystem.geometry.attributes.position.array;

        // Update particle positions
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const velocity = velocities[i];

          // Update positions
          positions[i3] += velocity.x;
          positions[i3 + 1] += velocity.y;
          positions[i3 + 2] += velocity.z;

          // Simplified boundary checking
          if (Math.abs(positions[i3]) > 10) positions[i3] = -positions[i3];
          if (Math.abs(positions[i3 + 1]) > 10)
            positions[i3 + 1] = -positions[i3 + 1];
          if (Math.abs(positions[i3 + 2]) > 10)
            positions[i3 + 2] = -positions[i3 + 2];
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        shadowSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.rotation.y += 0.001;
        shadowSystem.rotation.y += 0.001;
        controls.update();
        renderer.render(scene, camera);
      }

      // Optimized window resize handler
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start animation
      animate();
    </script>
  </body>
</html>
