<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>memory_almost_full</title>
    <style>
      @font-face {
        font-family: "SourceCodePro";
        src: url("assets/SourceCodePro-VariableFont_wght.ttf")
          format("truetype");
      }
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #c0d0d0;
      }
      canvas {
        display: block;
        opacity: 0;
        transition: opacity 2s ease-in;
      }

      canvas.fade-in {
        opacity: 1;
      }
      #title {
        position: absolute;
        top: 20px;
        left: 20px;
        color: black;
        font-size: 36px;
        font-weight: bold;
        font-family: "SourceCodePro", monospace;
        z-index: 100;
        text-align: left;
        letter-spacing: 2px;
        text-shadow: 2px 2px 4px rgba(76, 30, 30, 0.454);
      }
    </style>
  </head>
  <body>
    <div id="title">memory_almost_full</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: false, // Disable antialiasing for better performance
        powerPreference: "high-performance", // Use dedicated GPU if available
      });
      renderer.shadowMap.enabled = false; // Disable shadows for better performance
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xc0d0d0);
      document.body.appendChild(renderer.domElement);

      // Lighting with shadows
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // ASCII characters from the attached photo
      const asciiChars = [
        // Main character set (large, black font)
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "@",
        "[",
        "\\",
        "]",
        "↑",
        "←",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        // Smaller grey characters and symbols
        "▪",
        "N",
        "S",
        "E",
        "B",
        "H",
        "L",
        "V",
        "F",
        "C",
        "D",
        "A",
        "K",
        "Y",
        "M",
        "G",
        "R",
        "U",
        "O",
        "T",
        "X",
        "Q",
        "I",
        "1",
        "2",
        "3",
        "4",
      ];

      // ASCII text sprites system (reduced count for better performance)
      const textCount = 50; // Reduced from 80 to 50 for better performance
      const textSprites = [];
      const velocities = [];

      // Create shared texture for all ASCII characters (performance optimization)
      const sharedCanvas = document.createElement("canvas");
      const sharedContext = sharedCanvas.getContext("2d");
      sharedCanvas.width = 64;
      sharedCanvas.height = 64;

      // Set font and style
      sharedContext.font = "32px SourceCodePro, monospace";
      sharedContext.fillStyle = "rgba(60, 60, 60, 0.8)";
      sharedContext.textAlign = "center";
      sharedContext.textBaseline = "middle";

      // Draw a generic character for shared texture
      sharedContext.fillText("A", 32, 32);

      // Create shared texture
      const sharedTexture = new THREE.CanvasTexture(sharedCanvas);
      sharedTexture.needsUpdate = true;

      // Create shared sprite material
      const sharedSpriteMaterial = new THREE.SpriteMaterial({
        map: sharedTexture,
        transparent: true,
        opacity: 0.8,
        alphaTest: 0.1,
      });

      // Create text sprites with shared material
      for (let i = 0; i < textCount; i++) {
        // Create sprite with shared material
        const sprite = new THREE.Sprite(sharedSpriteMaterial.clone());
        sprite.scale.set(1, 1, 1);

        // Random position in 3D space - further from camera
        sprite.position.set(
          (Math.random() - 0.5) * 60,
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 60
        );

        // Random velocities for floating motion
        velocities.push({
          x: (Math.random() - 0.5) * 0.02,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.02,
        });

        textSprites.push(sprite);
        scene.add(sprite);
      }

      // Artist images as billboard planes
      const artistImages = [
        {
          name: "Anat Saacks",
          path: "assets/Artists/Anat Saacks/Anat Saacks.jpg",
        },
        {
          name: "Chenn Hearthstone",
          path: "assets/Artists/Chenn Hearthstone/Chenn Hearthstone_placeholder.png",
        },
        {
          name: "Dafna Sartiel",
          path: "assets/Artists/Dafna Sartiel/Dafna_Sartiel.jpg",
        },
        {
          name: "Eitan Bartal",
          path: "assets/Artists/Eitan Bartal/EitanBartal_placeholder.png",
        },
        {
          name: "Eyal Datz",
          path: "assets/Artists/Eyal Datz/Eyal Datz_placeholder.png",
        },
        {
          name: "Eyal Yehowa Gruss",
          path: "assets/Artists/Eyal Yehowa Gruss/Eyal Yehowa Gruss_placeholder.png",
        },
        {
          name: "Gilad Friedman",
          path: "assets/Artists/Gilad Friedman/Gilad Fridman.jpg",
        },
        {
          name: "Haya Sheffer",
          path: "assets/Artists/Haya Sheffer/Haya Sheffer.jpg",
        },
        {
          name: "Naama Steinbock",
          path: "assets/Artists/Naama Steinbock/Naama Steinbock.jpg",
        },
        {
          name: "Oded Ezer",
          path: "assets/Artists/Oded Ezer/Oded Ezer_placeholder.png",
        },
        {
          name: "Ofir Liberman",
          path: "assets/Artists/Ofir Liberman/ofir_liberman.jpg",
        },
        {
          name: "Rony Ginosar",
          path: "assets/Artists/Rony Ginosar/Rony Ginosar.jpg",
        },
        {
          name: "Shaul Tzemach",
          path: "assets/Artists/Shaul Tzemach/fbm_b134006708485641932.png",
        },
        {
          name: "Yoav Ruda",
          path: "assets/Artists/Yoav Ruda/Yoav Ruda_placeholder.png",
        },
        {
          name: "Yonatan Ben-Simhon and Mattan Tenne",
          path: "assets/Artists/Yonatan Ben-Simhon and Mattan Tenne/yonatan ben-simhon.jpeg",
        },
        {
          name: "Yuval Keshet",
          path: "assets/Artists/Yuval Keshet/Yuval Keshet.JPG",
        },
      ];

      const imagePlanes = [];
      const textureLoader = new THREE.TextureLoader();
      const connectionLines = [];

      // Preload all images in parallel for faster loading
      function preloadImages() {
        const loadPromises = artistImages.map((artist) => {
          return new Promise((resolve, reject) => {
            const texture = textureLoader.load(
              artist.path,
              (loadedTexture) => {
                // Optimize texture settings for better performance
                loadedTexture.generateMipmaps = false;
                loadedTexture.minFilter = THREE.LinearFilter;
                loadedTexture.magFilter = THREE.LinearFilter;
                loadedTexture.format = THREE.RGBAFormat;
                loadedTexture.flipY = true;

                resolve({ artist, texture: loadedTexture });
              },
              undefined,
              (error) => {
                console.warn(`Failed to load image: ${artist.path}`, error);
                reject(error);
              }
            );
          });
        });

        return Promise.all(loadPromises);
      }

      // Create all image planes after preloading
      preloadImages()
        .then((loadedTextures) => {
          loadedTextures.forEach(({ artist, texture }) => {
            // Calculate aspect ratio from loaded texture
            const aspectRatio = texture.image.width / texture.image.height;
            const baseHeight = 2.5;
            const width = baseHeight * aspectRatio;

            // Create geometry with proper aspect ratio
            const geometry = new THREE.PlaneGeometry(width, baseHeight);

            const material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              opacity: 0.95,
              side: THREE.DoubleSide,
              alphaTest: 0.1, // Optimize transparency rendering
            });

            const plane = new THREE.Mesh(geometry, material);

            // Random position in 3D space
            plane.position.set(
              (Math.random() - 0.5) * 30,
              (Math.random() - 0.5) * 20,
              (Math.random() - 0.5) * 30
            );

            // Ensure images render in front of lines
            plane.renderOrder = 1;

            // Store reference for billboard behavior
            plane.userData = { isBillboard: true };
            imagePlanes.push(plane);
            scene.add(plane);
          });

          // Create connections after all images are loaded
          createConnections();

          // Trigger fade-in effect once everything is loaded
          setTimeout(() => {
            renderer.domElement.classList.add("fade-in");
            // Start rotation animation after fade-in begins
            rotationStartTime = Date.now();
            isRotating = true;
          }, 100); // Small delay to ensure everything is rendered
        })
        .catch((error) => {
          console.error("Error loading images:", error);
          // Still trigger fade-in even if some images fail to load
          setTimeout(() => {
            renderer.domElement.classList.add("fade-in");
            // Start rotation animation after fade-in begins
            rotationStartTime = Date.now();
            isRotating = true;
          }, 100);
        });

      // Function to create connections between images (optimized)
      function createConnections() {
        // Reduce number of connections for better performance
        const maxConnections = Math.min(imagePlanes.length * 0.5, 20); // Limit total connections
        let connectionCount = 0;

        for (
          let i = 0;
          i < imagePlanes.length && connectionCount < maxConnections;
          i++
        ) {
          // Each image connects to 1-2 other images (reduced from 1-3)
          const numConnections = Math.floor(Math.random() * 2) + 1;
          const connectedIndices = new Set();

          // Ensure we don't connect to the same image
          while (
            connectedIndices.size < numConnections &&
            connectedIndices.size < imagePlanes.length - 1 &&
            connectionCount < maxConnections
          ) {
            const randomIndex = Math.floor(Math.random() * imagePlanes.length);
            if (randomIndex !== i) {
              connectedIndices.add(randomIndex);
            }
          }

          // Create lines to connected images
          connectedIndices.forEach((targetIndex) => {
            if (connectionCount >= maxConnections) return;

            const startPos = imagePlanes[i].position;
            const endPos = imagePlanes[targetIndex].position;

            // Create line geometry
            const points = [
              new THREE.Vector3(startPos.x, startPos.y, startPos.z),
              new THREE.Vector3(endPos.x, endPos.y, endPos.z),
            ];

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Create line material with optimized settings
            const material = new THREE.LineBasicMaterial({
              color: 0x666666,
              transparent: true,
              opacity: 0.4,
              linewidth: 1,
              depthTest: true,
              depthWrite: false,
              vertexColors: false, // Disable vertex colors for performance
            });

            const line = new THREE.Line(geometry, material);
            line.renderOrder = -1; // Render before other objects
            line.frustumCulled = true; // Enable frustum culling
            connectionLines.push(line);
            scene.add(line);
            connectionCount++;
          });
        }
      }

      // Camera position
      camera.position.z = 15;

      // Simplified orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;
      controls.enablePan = true;

      // Performance optimization variables
      let frameCount = 0;
      const updateFrequency = 2; // Update sprites every 2 frames instead of every frame
      const frustum = new THREE.Frustum();
      const cameraMatrix = new THREE.Matrix4();

      // Rotation animation variables
      let rotationStartTime = null;
      const rotationDuration = 3000; // 3 seconds in milliseconds
      let isRotating = false;

      // Easing function for smooth rotation (ease-in-out)
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      // Optimized animation loop
      function animate() {
        requestAnimationFrame(animate);
        frameCount++;

        // Update camera matrix for frustum culling
        cameraMatrix.multiplyMatrices(
          camera.projectionMatrix,
          camera.matrixWorldInverse
        );
        frustum.setFromProjectionMatrix(cameraMatrix);

        // Update ASCII sprite positions (reduced frequency for performance)
        if (frameCount % updateFrequency === 0) {
          for (let i = 0; i < textCount; i++) {
            const sprite = textSprites[i];
            const velocity = velocities[i];

            // Update positions
            sprite.position.x += velocity.x * updateFrequency;
            sprite.position.y += velocity.y * updateFrequency;
            sprite.position.z += velocity.z * updateFrequency;

            // Improved boundary checking - wrap around instead of bounce
            if (Math.abs(sprite.position.x) > 30) {
              sprite.position.x = sprite.position.x > 0 ? -30 : 30;
            }
            if (Math.abs(sprite.position.y) > 20) {
              sprite.position.y = sprite.position.y > 0 ? -20 : 20;
            }
            if (Math.abs(sprite.position.z) > 30) {
              sprite.position.z = sprite.position.z > 0 ? -30 : 30;
            }

            // Add subtle rotation to sprites
            sprite.rotation.z += 0.001 * updateFrequency;
          }
        }

        // Handle rotation animation
        if (isRotating && rotationStartTime !== null) {
          const currentTime = Date.now();
          const elapsed = currentTime - rotationStartTime;
          const progress = Math.min(elapsed / rotationDuration, 1);

          if (progress < 1) {
            // Apply easing and rotate around Y-axis
            const easedProgress = easeInOutCubic(progress);
            const rotationAngle = (easedProgress * Math.PI) / 4; // Rotate 45 degrees (π/4 radians) to the left

            // Rotate the entire scene around Y-axis
            scene.rotation.y = rotationAngle;
          } else {
            // Animation complete
            isRotating = false;
            scene.rotation.y = Math.PI / 4; // Final rotation position
          }
        }

        // Optimized billboard behavior with frustum culling
        imagePlanes.forEach((plane) => {
          // Only update billboard behavior if plane is in view
          if (frustum.intersectsObject(plane)) {
            plane.lookAt(camera.position);
            plane.visible = true;
          } else {
            plane.visible = false; // Hide objects outside frustum
          }
        });

        controls.update();
        renderer.render(scene, camera);
      }

      // Optimized window resize handler
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start animation
      animate();
    </script>
  </body>
</html>
